%
% 6.857 homework template
%
% NOTE:
% Be sure to define your team members with the \team command
% Be sure to define the problem set with the \ps command
% Be sure to use the \answer command for each of your answers 
\documentclass[11pt]{article}

\newcommand{\team}{ Victor Williamson \\ Victor Chan \\ David Feldman }
\newcommand{\ps}{ Problem Set 2 }

%\pagestyle{headings}
\usepackage[dvips]{graphics,color}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{verbatim}
\usepackage{enumerate}
\setlength{\parskip}{1pc}
\setlength{\parindent}{0pt}
\setlength{\topmargin}{-3pc}
\setlength{\textheight}{9.5in}
\setlength{\oddsidemargin}{0pc}
\setlength{\evensidemargin}{0pc}
\setlength{\textwidth}{6.5in}

\newcommand{\answer}[1]{
\newpage
\noindent
\framebox{
	\vbox{
		6.857 Homework \hfill {\bf \ps} \hfill \# #1  \\ 
		\team \hfill \today
	}
}
\bigskip

}


\begin{document}

\answer{2-1 - MAC Attack}

a) This MAC procedure is not a good one. It is possible for an adversary to recover K using merely the original message M and MAC(K,M), both of which are sent in the clear
and are readily available to the adversary.

During creation of the MAC we let:
\newline
\begin{equation*}
V_0 = K
\end{equation*}
and proceed with 
\begin{equation*}
V_i = encryptAES(M_i,V_{i-1})
\end{equation*}
for each i = 1,2,...,n
\begin{equation}
MAC(K,M) = V_n
\end{equation}

It is very simple to reverse this procedure. We would again pad M and break it into n 128-bit blocks. We then use AES decryption as follows:

\begin{equation*}
V_{i-1} = decryptAES(M_(i), V_i)
\end{equation*}
for all i = n, n-1,...,1,0 where
\begin{equation*}
V_n = MAC(K,M)
\end{equation*}
as received from the sender, and
\begin{equation*}
K = V_0
\end{equation*} 

Once K is obtained then the attacker could write fake messages and pass them off as authentic by using the MAC creation procedure described above, since the key K is now known. Essentially, the problem occurred with this MAC procedure because it reversed the position of the key and message block within AES encryption. This change made it possible to recover the  secret key, which would have been used between the users to validate authenticity.

Note that
\begin{equation*}
xxxAES(K,B)
\end{equation*}
denotes the encrpytion or decryption of a 128-bit plaintext block B with a 128-bit key K using the AES algorithm.

b) Adding a checksum to this MAC will not make it any better. This adds no protection to the MAC because the XOR of the message blocks does not prevent the key from being retrieved. Since an attacker is able to retrieve K, they will still be able to create fake messages and the correct MAC's these messages. It would be trivial to add on an additional "correct" checksum of the fake message.  


\begin{comment}
Different font styles: 

Several ways to do \textit{italics}, {\it italics}, \emph{italics}.

Several ways to do \textbf{bold}, {\bf bold}.

Other fonts: \textsc{Blah}.

{\tiny tiny}, {\small small}, {\normalsize normalsize}, {\Large Large}. {\LARGE
LARGE}. {\huge huge}, {\Huge Huge}.

F\"{o}\.{r}\'{e}\r{i}\^{g}\u{n} Accents.
\end{comment}
\answer{2-2 - Truncated-Key AES}

\begin{comment}
Here's an example of how to do mathematical symbols in an Equation
array:

\begin{eqnarray*}
L & = & \mbox{Total lines of code.} \\
\rho & = & \mbox{Rate of line replacement.} \\
\delta & = & \mbox{Density of bugs in replaced line.} \\
V(t) & = & \mbox{Total number of vulnerabilities at time  } t. \\
\gamma & = & \mbox{Debugger inspection rate in the open source model.}\\
\hat{\gamma} & = & \mbox{Debugger inspection rate in the proprietary model .}\\
\beta & = & \mbox{Adversarial inspection rate in the open source model.}\\
\hat{\beta} & = & \mbox{Adversarial inspection rate in the proprietary model.}\\
\end{eqnarray*}

Or you can put symbols inline like this: $\rho$, $\gamma$, and
$\frac{\alpha}{\beta}$.

Some symbols that may come in handy someday: $\Theta$, $\oplus$, $\cdot$,
$\ldots$, $\rightarrow$, $\leq$, $\geq$, $m^e \bmod p$,  $\mathbb{N}$, $\mathbb{Z}$.

Superscripts and subscripts: $x^{super}_{sub}$.

Superscripts and subscripts in an equation environment: 
\begin{equation}
x^{super}_{sub}
\end{equation}
\end{comment}

\answer{2-3 - Ben's Block Cipher}
\begin{enumerate}[(a)]
	\item
	
  Consider a given key, (p,S,q). To be more concrete, let us first define our permutations p and q to be lists of numbers of length
  128 such that each number in 0...127 is represented once (it is a one-to-one mapping). If a 128-bit input is fed into a permutation,
  say p, then the output P[input] is defined such that output[k] = input[p[k]] for k in 0...127. Let us define S as a one-to-one mapping
  from $[0,1]^8 \Rightarrow [0,1]^8$.
  
  Now take p and chop it into groups of 8 bits, starting from the lsb (bit zero). Since S only operates on groups of 8 bits, we can permute these
  groups without changing the mappings being processed by the s-box. If we similarly chop q into 8-bit chunks and permute those in the exact
  same way that we permuted p, then the output bits of S will end up in the same location as in the original key. A 128-bit permutation is
  composed of 16 groups of 8 bits, and thus we can permute p and q in a byte-wise fashion to produce $16!$ equivalent keys without modifying S.
  
  Now that we have permuted the bytes, let us consider the bit-ordering inside the bytes. A short example might be illustrative: if, in every
  byte-sized chunk of p, we switch the first bit (i.e. bit zero) and the last bit (bit 7), then we can produce an equivalent key solely by
  swapping the first and last bits of every input key in the mapping defined by S. To generalize, we can permute the 8 bits that comprise each
  byte of p in any way that we would like and still end up with an equivalent key, so long as this 8-bit permutation is the same in each byte
  of p, and so long as we permute the bits of the byte-sized input keys of S in the same way as we permuted the bytes in p.
  
  Similarly, we can permute the 8-bit output values of S in any way that we would like and obtain equivalent keys,
  so long as every output value is permuted in the same way and so long as we do the same permutation on every byte in q.
  
  These 3 ways to produce equivalent keys, p/q byte-swapping, p/$S_{in}$ bit-swapping, and q/$S_{out}$ bit-swapping, do not overlap.
  Thus, since there are $8!$ ways to permute 8 bits, we haved found $16! \ast (8!)^2$ equivalent keys to (p,S,q).  

	\item
	It's important to note that there are many equivalent keys. Thus we can arbitrarily pick certain properties, and then make everything else work out to be consistent.

Here is a way to use a plaintext attack to break this cipher:

Encrypt 0x0h and 0x1h and compare the ciphertexts. We know that S is 1-to-1, and so bits in these 2 ciphertexts should differ in at least 1 and in at most 8 positions. Now encrypt  the other 127 plaintexts where there is a single one bit (i.e. 0x2h, 0x4h, 0x8h, 0x10h,etc). We can similarly compare these ciphertexts to the 0x0h ciphertexts, and mark at which 8 positions the bits differ. Since each bit is part of 1 of the 16 bytes, there should be 16 groups of 8 ciphertexts where the differing bits overlap. Hopefully each group of 8 should in total have 8 bits that differ from the 0x0h ciphertext. It is possible, albeit unlikely, to have less (the minimum is 4). If this is the case, we would look
to see which bits in the input triggered differing bits in the output, and then encrypt more plaintexts where we set multiple of these input
bits at a time to 1, looking for more differences from 0x0h until we have 8 bits in each group.

Thus what we have determined is which bits belong together in a byte after p but before q.

We do not know the ordering the different bytes after p, just which bits are part of a single byte. However, note from part a that if we swap the ordering of the bytes produced by p, we can create an equivalent key merely by doing a similar swap on q. Thus, we select an arbitrary ordering of the 16 bytes we found, and use this ordering to begin to partially define p and q.

We also do not yet know how the bits are ordered inside each of the 16 bytes (we just know which bits belong to which byte). Once again, recall from part a that if we alter the inner ordering we can make an equivalent change in the s-box. Now consider the ciphertexts we produced previously for 0x0h,0x1h,0x2h,etc. These ciphertexts can be divided into 9 distinguishable types. After the s-box but before q, 0x0h produces 16 copies of the 0x00h byte mapping, while the others produce 15 copies of the 0x00h byte mapping and 1 copy of the mapping from either 1,2,4,8,16,32,64, or 128 decimal. The later 8 types (i.e. not 0x0h) all have 16 members, representing a common position in the byte. Due to the key equivalence, we can arbitrarily select one of these types to represent the 1st bit, another the 2nd bit, another the 3rd bit,..., and the last the 8th bit. Given these bit groupings, we have fully established p.

We can similarly use key equivalence to establish q as follows. Look at the 0x0h ciphertext. Count all of the ones and all of the zeros and divide each count by 16. We now know how many ones and how many zeros are in the output value defined by S for the input 0x00h. These counts are the 'unique' information; the ordering is arbitrary since we can then adjust q to be consistent. Thus we just pick some bit ordering and let it be the official mapped value for 0x00h (perhaps the ordering created by looking at the 1st byte and reading the bits left to right). We already knew the ordering of the bytes coming out of the s-box (we chose it earlier), and we now know the identity of the byte coming out of the s-box for the input 0x00h. Thus we can just match up the bits inside the bytes to the corresponding bits in the 0x0h ciphertext. This completely defines q.

Since we have established p and q, we can easily enumerate each key,value pair in the s-box by looking at the plaintext/ciphertext pairs for 0x00h-0xFFh, tracing from the input to just before the s-box using p and from the output to just after the s-box using q.

\end{enumerate}

\end{document}


